<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Ben Brintz - Model Watchtower v1 Demo</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>


<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/tabby.min.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-html.min.css" rel="stylesheet" data-mode="light">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">


<link rel="stylesheet" href="custom-layout.css">
</head>

<body>


<header id="title-block-header">
<h1 class="title">Model Watchtower v1 Demo</h1>

</header>


<div>
<style>
  :root {
    --bg: #f6f8fb;
    --panel: #ffffff;
    --ink: #10253f;
    --muted: #5a6d82;
    --line: #d7e0eb;
    --ok: #2f9e44;
    --watch: #c97b00;
    --warn: #d9480f;
    --action: #b42318;
    --accent: #0f6cbd;
    --chip: #eaf2fb;
  }

  body {
    margin: 0;
    background: radial-gradient(circle at 12% 8%, #e9f3ff, transparent 32%),
      radial-gradient(circle at 88% 86%, #fdeed8, transparent 34%),
      var(--bg);
    color: var(--ink);
    font-family: "IBM Plex Sans", "Avenir Next", "Segoe UI", sans-serif;
  }

  .page {
    max-width: 1240px;
    margin: 1.1rem auto 2rem auto;
    padding: 0 0.9rem;
  }

  .topbar {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 0.8rem;
    margin-bottom: 0.85rem;
  }

  .title {
    font-size: clamp(1.35rem, 2.3vw, 1.9rem);
    margin: 0;
    letter-spacing: 0.01em;
  }

  .subtitle {
    margin: 0.2rem 0 0 0;
    color: var(--muted);
    font-size: 0.95rem;
  }

  .ctrls {
    display: flex;
    gap: 0.6rem;
    flex-wrap: wrap;
    justify-content: flex-end;
  }

  .ctrl {
    background: var(--panel);
    border: 1px solid var(--line);
    border-radius: 12px;
    padding: 0.45rem 0.55rem;
    display: grid;
    gap: 0.22rem;
    min-width: 155px;
  }

  .ctrl label {
    font-size: 0.74rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--muted);
    font-weight: 700;
  }

  .ctrl input,
  .ctrl select {
    border: 1px solid #c8d6e7;
    border-radius: 8px;
    padding: 0.35rem 0.45rem;
    font-size: 0.9rem;
    color: var(--ink);
    background: #fff;
  }

  .kpi-grid {
    display: grid;
    grid-template-columns: repeat(5, minmax(0, 1fr));
    gap: 0.6rem;
    margin-bottom: 0.85rem;
  }

  .kpi {
    border: 1px solid var(--line);
    border-radius: 14px;
    background: var(--panel);
    padding: 0.72rem;
  }

  .kpi h3 {
    margin: 0;
    color: var(--muted);
    font-size: 0.72rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }

  .kpi .value {
    margin-top: 0.32rem;
    font-size: 1.25rem;
    font-weight: 700;
    line-height: 1.2;
  }

  .chip {
    display: inline-block;
    margin-top: 0.3rem;
    padding: 0.15rem 0.48rem;
    border-radius: 999px;
    background: var(--chip);
    font-size: 0.76rem;
    color: #21496f;
  }

  .layout {
    display: grid;
    grid-template-columns: 1.7fr 1fr;
    gap: 0.6rem;
  }

  .panel {
    border: 1px solid var(--line);
    border-radius: 14px;
    background: var(--panel);
    padding: 0.72rem;
  }

  .panel-title {
    margin: 0 0 0.48rem 0;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--muted);
  }

  canvas {
    width: 100%;
    border: 1px solid #e3eaf2;
    border-radius: 10px;
    background: #fcfdff;
  }

  .right-stack {
    display: grid;
    gap: 0.6rem;
    align-content: start;
  }

  .alert-list {
    margin: 0;
    padding: 0;
    list-style: none;
    max-height: 240px;
    overflow: auto;
  }

  .alert-item {
    border: 1px solid #e6ebf2;
    border-radius: 10px;
    padding: 0.5rem;
    margin-bottom: 0.45rem;
    background: #fafcff;
  }

  .alert-head {
    display: flex;
    justify-content: space-between;
    gap: 0.5rem;
    font-size: 0.85rem;
    font-weight: 700;
  }

  .alert-meta {
    font-size: 0.8rem;
    color: var(--muted);
    margin-top: 0.12rem;
  }

  .badge {
    border-radius: 999px;
    padding: 0.1rem 0.5rem;
    font-size: 0.74rem;
    color: #fff;
  }

  .badge.normal { background: #4f6b87; }
  .badge.watch { background: var(--watch); }
  .badge.warning { background: var(--warn); }
  .badge.action { background: var(--action); }

  .mini-grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 0.45rem;
  }

  .mini {
    border: 1px solid #e7edf5;
    border-radius: 10px;
    padding: 0.45rem;
    font-size: 0.81rem;
  }

  .mini .m-title {
    color: var(--muted);
    font-size: 0.72rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .mini .m-val {
    font-weight: 700;
    margin-top: 0.2rem;
    font-size: 0.98rem;
  }

  .bottom {
    margin-top: 0.6rem;
    display: grid;
    gap: 0.6rem;
    grid-template-columns: 1.2fr 1fr;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.86rem;
  }

  th,
  td {
    border-bottom: 1px solid #e6edf5;
    text-align: left;
    padding: 0.38rem;
  }

  th {
    color: var(--muted);
    font-size: 0.73rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .runbook {
    border: 1px dashed #b8c8dc;
    border-radius: 10px;
    padding: 0.45rem;
    font-size: 0.86rem;
    background: #f8fbff;
  }

  @media (max-width: 1040px) {
    .kpi-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    .layout,
    .bottom { grid-template-columns: 1fr; }
  }
</style>

<div class="page">
  <div class="topbar">
    <div>
      <h1 class="title">Model Watchtower v1</h1>
      <p class="subtitle">Synthetic demo: anomaly + drift + subgroup gap monitoring for daily call volume</p>
    </div>

    <div class="ctrls">
      <div class="ctrl">
        <label for="dateStart">Start date</label>
        <input type="date" id="dateStart">
      </div>
      <div class="ctrl">
        <label for="dateEnd">End date</label>
        <input type="date" id="dateEnd">
      </div>
      <div class="ctrl">
        <label for="sensitivity">Alert sensitivity</label>
        <select id="sensitivity">
          <option value="conservative">Conservative</option>
          <option value="balanced" selected="">Balanced</option>
          <option value="sensitive">Sensitive</option>
        </select>
      </div>
      <div class="ctrl">
        <label for="subgroup">Subgroup focus</label>
        <select id="subgroup">
          <option value="all" selected="">All</option>
          <option value="female">Female</option>
          <option value="male">Male</option>
          <option value="older">Age 65+</option>
          <option value="younger">Under 65</option>
        </select>
      </div>
    </div>
  </div>

  <section class="kpi-grid">
    <div class="kpi"><h3 class="anchored">Current risk level</h3><div class="value" id="kpiRisk">-</div><span class="chip" id="kpiRiskReason">-</span></div>
    <div class="kpi"><h3 class="anchored">Drift score (7d)</h3><div class="value" id="kpiDrift">-</div><span class="chip" id="kpiDriftReason">-</span></div>
    <div class="kpi"><h3 class="anchored">Subgroup gap</h3><div class="value" id="kpiGap">-</div><span class="chip" id="kpiGapReason">-</span></div>
    <div class="kpi"><h3 class="anchored">Anomaly probability</h3><div class="value" id="kpiAnom">-</div><span class="chip" id="kpiAnomReason">-</span></div>
    <div class="kpi"><h3 class="anchored">Recommended action</h3><div class="value" id="kpiAction">-</div><span class="chip" id="kpiActionEta">-</span></div>
  </section>

  <section class="layout">
    <div class="panel">
      <h2 class="panel-title anchored">Observed vs latent baseline (with 90% credible interval)</h2>
      <canvas id="trendCanvas" width="860" height="350"></canvas>
    </div>

    <div class="right-stack">
      <div class="panel">
        <h2 class="panel-title anchored">Alert feed</h2>
        <ul id="alertList" class="alert-list"></ul>
      </div>

      <div class="panel">
        <h2 class="panel-title anchored">What changed</h2>
        <div class="mini-grid">
          <div class="mini"><div class="m-title">Trend shift</div><div id="mTrend" class="m-val">-</div></div>
          <div class="mini"><div class="m-title">Dispersion</div><div id="mDisp" class="m-val">-</div></div>
          <div class="mini"><div class="m-title">Detection confidence</div><div id="mConf" class="m-val">-</div></div>
        </div>
      </div>

      <div class="panel">
        <h2 class="panel-title anchored">Runbook</h2>
        <div id="runbook" class="runbook"></div>
      </div>
    </div>
  </section>

  <section class="bottom">
    <div class="panel">
      <h2 class="panel-title anchored">Subgroup metrics (window summary)</h2>
      
<table data-quarto-postprocess="true">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">Group</th>
<th data-quarto-table-cell-role="th">Calibration slope</th>
<th data-quarto-table-cell-role="th">FPR</th>
<th data-quarto-table-cell-role="th">TPR</th>
<th data-quarto-table-cell-role="th">Gap vs overall</th>
<th data-quarto-table-cell-role="th">Status</th>
</tr>
</thead>
<tbody id="subgroupBody">
</tbody>
</table>

    </div>

    <div class="panel">
      <h2 class="panel-title anchored">Gap over time</h2>
      <canvas id="gapCanvas" width="540" height="240"></canvas>
    </div>
  </section>
</div>

<script>
  function seededRandom(seed) {
    let t = seed;
    return function() {
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  }

  const rand = seededRandom(42);
  const startDate = new Date("2025-08-01");
  const days = 190;

  const data = Array.from({ length: days }, (_, i) => {
    const d = new Date(startDate);
    d.setDate(d.getDate() + i);

    const weekly = 7 * Math.sin((2 * Math.PI * i) / 7 + 0.4);
    const seasonal = 10 * Math.sin((2 * Math.PI * i) / 42 - 0.7);
    const trend = 34 + i * 0.08;
    const shock = (i > 115 && i < 130) ? 14 : (i > 155 && i < 166 ? 19 : 0);

    const latent = trend + weekly + seasonal + shock;
    const noise = (rand() - 0.5) * 14;
    const observed = Math.max(0, latent + noise);

    const ciWidth = 7 + (i > 155 && i < 166 ? 4 : 0);
    const low = Math.max(0, latent - ciWidth);
    const high = latent + ciWidth;

    const anomalyProb = Math.max(0, Math.min(1, 0.18 + Math.abs(observed - latent) / 28 + (shock > 0 ? 0.22 : 0)));
    const drift = Math.max(0, Math.min(1, 0.2 + Math.max(0, i - 140) / 95 + (shock > 0 ? 0.12 : 0)));

    const gap = Math.max(0, Math.min(0.20, 0.03 + (i > 145 ? (i - 145) / 650 : 0) + (i > 155 && i < 166 ? 0.035 : 0) + (rand() - 0.5) * 0.01));

    return {
      date: d,
      observed,
      latent,
      low,
      high,
      anomalyProb,
      drift,
      gap,
      subgroup: {
        female: { fpr: 0.18 + gap * 0.8, tpr: 0.71 - gap * 0.15, cal: 0.97 - gap * 0.4 },
        male: { fpr: 0.16, tpr: 0.74, cal: 1.01 },
        older: { fpr: 0.22 + gap * 0.5, tpr: 0.67 - gap * 0.08, cal: 0.92 - gap * 0.35 },
        younger: { fpr: 0.14, tpr: 0.76, cal: 1.03 }
      }
    };
  });

  const els = {
    dateStart: document.getElementById("dateStart"),
    dateEnd: document.getElementById("dateEnd"),
    sensitivity: document.getElementById("sensitivity"),
    subgroup: document.getElementById("subgroup"),
    trendCanvas: document.getElementById("trendCanvas"),
    gapCanvas: document.getElementById("gapCanvas"),
    alertList: document.getElementById("alertList"),
    subgroupBody: document.getElementById("subgroupBody"),
    kpiRisk: document.getElementById("kpiRisk"),
    kpiRiskReason: document.getElementById("kpiRiskReason"),
    kpiDrift: document.getElementById("kpiDrift"),
    kpiDriftReason: document.getElementById("kpiDriftReason"),
    kpiGap: document.getElementById("kpiGap"),
    kpiGapReason: document.getElementById("kpiGapReason"),
    kpiAnom: document.getElementById("kpiAnom"),
    kpiAnomReason: document.getElementById("kpiAnomReason"),
    kpiAction: document.getElementById("kpiAction"),
    kpiActionEta: document.getElementById("kpiActionEta"),
    mTrend: document.getElementById("mTrend"),
    mDisp: document.getElementById("mDisp"),
    mConf: document.getElementById("mConf"),
    runbook: document.getElementById("runbook")
  };

  function fmtDate(d) {
    return d.toISOString().slice(0, 10);
  }

  els.dateStart.value = fmtDate(data[days - 90].date);
  els.dateEnd.value = fmtDate(data[days - 1].date);

  function thresholds(mode) {
    if (mode === "conservative") return { watch: 0.72, warning: 0.83, action: 0.92, gap: 0.085 };
    if (mode === "sensitive") return { watch: 0.56, warning: 0.68, action: 0.8, gap: 0.06 };
    return { watch: 0.62, warning: 0.75, action: 0.88, gap: 0.072 };
  }

  function statusFrom(score, t) {
    if (score >= t.action) return "Action";
    if (score >= t.warning) return "Warning";
    if (score >= t.watch) return "Watch";
    return "Normal";
  }

  function statusClass(s) {
    return s.toLowerCase();
  }

  function average(arr, fn) {
    if (!arr.length) return 0;
    return arr.reduce((a, x) => a + fn(x), 0) / arr.length;
  }

  function effectiveGap(r, focus) {
    if (focus === "all") return r.gap;
    const groups = ["female", "male", "older", "younger"];
    const overallFpr = average(groups.map((g) => r.subgroup[g]), (x) => x.fpr);
    return Math.abs(r.subgroup[focus].fpr - overallFpr);
  }

  function subset() {
    const s = new Date(els.dateStart.value + "T00:00:00");
    const e = new Date(els.dateEnd.value + "T00:00:00");
    return data.filter((r) => r.date >= s && r.date <= e);
  }

  function drawTrend(records, riskScore, riskStatus) {
    const c = els.trendCanvas;
    const ctx = c.getContext("2d");
    const w = c.width;
    const h = c.height;

    ctx.clearRect(0, 0, w, h);
    const m = { t: 18, r: 16, b: 28, l: 36 };
    const pw = w - m.l - m.r;
    const ph = h - m.t - m.b;

    const ymax = Math.max(...records.map((d) => Math.max(d.observed, d.high))) * 1.1;
    const x = (i) => m.l + (i / (records.length - 1 || 1)) * pw;
    const y = (v) => m.t + ph - (v / ymax) * ph;

    ctx.strokeStyle = "#d5e0ec";
    ctx.lineWidth = 1;
    for (let k = 0; k <= 5; k++) {
      const gy = m.t + (k / 5) * ph;
      ctx.beginPath();
      ctx.moveTo(m.l, gy);
      ctx.lineTo(m.l + pw, gy);
      ctx.stroke();
    }

    if (riskStatus === "Action") {
      ctx.fillStyle = "rgba(180,35,24,0.09)";
      ctx.fillRect(m.l + pw * 0.78, m.t, pw * 0.22, ph);
    }

    ctx.beginPath();
    records.forEach((d, i) => {
      const px = x(i);
      const py = y(d.low);
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    });
    for (let i = records.length - 1; i >= 0; i--) {
      const d = records[i];
      ctx.lineTo(x(i), y(d.high));
    }
    ctx.closePath();
    ctx.fillStyle = "rgba(31,111,184,0.14)";
    ctx.fill();

    ctx.beginPath();
    records.forEach((d, i) => {
      const px = x(i);
      const py = y(d.latent);
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    });
    ctx.strokeStyle = "#155fa0";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = "#e17822";
    records.forEach((d, i) => {
      if (i % 2 !== 0) return;
      ctx.beginPath();
      ctx.arc(x(i), y(d.observed), 2.2, 0, Math.PI * 2);
      ctx.fill();
    });

    ctx.fillStyle = "#4f657d";
    ctx.font = "12px sans-serif";
    ctx.fillText("0", 10, y(0) + 3);
    ctx.fillText(Math.round(ymax / 2).toString(), 6, y(ymax / 2) + 3);
    ctx.fillText(Math.round(ymax).toString(), 6, y(ymax) + 3);

    ctx.fillStyle = "#213a56";
    ctx.font = "bold 12px sans-serif";
    ctx.fillText(`Risk score: ${riskScore.toFixed(2)} (${riskStatus})`, m.l + 8, m.t + 14);
    ctx.fillStyle = "#5a6d82";
    ctx.font = "11px sans-serif";
    ctx.fillText("Orange points: observed | Blue line: latent baseline | Blue band: 90% credible interval", m.l + 8, h - 8);
  }

  function drawGap(records, thGap) {
    const c = els.gapCanvas;
    const ctx = c.getContext("2d");
    const w = c.width;
    const h = c.height;
    const m = { t: 18, r: 12, b: 24, l: 34 };
    const pw = w - m.l - m.r;
    const ph = h - m.t - m.b;

    ctx.clearRect(0, 0, w, h);
    const ymax = Math.max(0.11, ...records.map((d) => d.gap * 1.15));
    const x = (i) => m.l + (i / (records.length - 1 || 1)) * pw;
    const y = (v) => m.t + ph - (v / ymax) * ph;

    ctx.strokeStyle = "#e0e8f1";
    ctx.lineWidth = 1;
    for (let k = 0; k <= 4; k++) {
      const gy = m.t + (k / 4) * ph;
      ctx.beginPath();
      ctx.moveTo(m.l, gy);
      ctx.lineTo(m.l + pw, gy);
      ctx.stroke();
    }

    ctx.setLineDash([5, 4]);
    ctx.beginPath();
    ctx.moveTo(m.l, y(thGap));
    ctx.lineTo(m.l + pw, y(thGap));
    ctx.strokeStyle = "#b42318";
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.beginPath();
    records.forEach((d, i) => {
      const px = x(i);
      const py = y(d.gap);
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    });
    ctx.strokeStyle = "#0f6cbd";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = "#5a6d82";
    ctx.font = "11px sans-serif";
    ctx.fillText(`Threshold ${Math.round(thGap * 100)}%`, m.l + 6, y(thGap) - 6);
  }

  function renderSubgroup(records, thGap, focus) {
    const last = records[records.length - 1];
    if (!last) {
      els.subgroupBody.innerHTML = "";
      return;
    }

    const groups = ["female", "male", "older", "younger"];
    const overallFpr = average(groups.map((g) => last.subgroup[g]), (x) => x.fpr);
    const viewGroups = focus === "all" ? groups : [focus];

    const rows = viewGroups.map((g) => {
      const m = last.subgroup[g];
      const gap = Math.abs(m.fpr - overallFpr);
      const status = gap > thGap ? "Breach" : "OK";
      return `<tr>
        <td>${g}</td>
        <td>${m.cal.toFixed(2)}</td>
        <td>${(m.fpr * 100).toFixed(1)}%</td>
        <td>${(m.tpr * 100).toFixed(1)}%</td>
        <td>${(gap * 100).toFixed(1)} pp</td>
        <td>${status}</td>
      </tr>`;
    });

    els.subgroupBody.innerHTML = rows.join("");
  }

  function renderAlerts(records, th, focus) {
    const alerts = [];
    for (let i = Math.max(0, records.length - 28); i < records.length; i++) {
      const r = records[i];
      const gap = effectiveGap(r, focus);
      const score = 0.5 * r.anomalyProb + 0.35 * r.drift + 0.15 * Math.min(1, gap / (th.gap || 0.001));
      const level = statusFrom(score, th);
      if (level === "Normal") continue;
      const reason = gap > th.gap ? "subgroup gap + anomaly" : "anomaly + drift";
      alerts.push({
        date: fmtDate(r.date),
        level,
        prob: Math.round(score * 100),
        reason
      });
    }

    alerts.sort((a, b) => (a.date < b.date ? 1 : -1));
    const slice = alerts.slice(0, 8);

    els.alertList.innerHTML = slice.length ? slice.map((a) => `
      <li class="alert-item">
        <div class="alert-head">
          <span>${a.date}</span>
          <span class="badge ${statusClass(a.level)}">${a.level}</span>
        </div>
        <div class="alert-meta">Posterior alert probability: ${a.prob}%</div>
        <div class="alert-meta">Signal: ${a.reason}</div>
      </li>
    `).join("") : `<li class="alert-item"><div class="alert-meta">No active alerts in this window.</div></li>`;
  }

  function renderKpis(records, th, focus) {
    const n = records.length;
    if (!n) return;
    const recent = records.slice(Math.max(0, n - 7));

    const anom = average(recent, (d) => d.anomalyProb);
    const drift = average(recent, (d) => d.drift);
    const gap = average(recent, (d) => effectiveGap(d, focus));
    const score = 0.5 * anom + 0.35 * drift + 0.15 * Math.min(1, gap / (th.gap || 0.001));
    const status = statusFrom(score, th);

    els.kpiRisk.innerHTML = `<span class="badge ${statusClass(status)}">${status}</span>`;
    els.kpiRiskReason.textContent = `Composite score ${score.toFixed(2)}`;

    els.kpiDrift.textContent = drift.toFixed(2);
    els.kpiDriftReason.textContent = drift > 0.6 ? "Above watch threshold" : "Stable baseline";

    els.kpiGap.textContent = `${(gap * 100).toFixed(1)} pp`;
    els.kpiGapReason.textContent = gap > th.gap ? "Threshold exceeded" : "Within tolerance";

    els.kpiAnom.textContent = `${Math.round(anom * 100)}%`;
    els.kpiAnomReason.textContent = anom > 0.8 ? "Persistent anomalies" : "Intermittent anomalies";

    let action = "Maintain baseline staffing";
    let eta = "Review in 72h";
    if (status === "Watch") {
      action = "Prep escalation protocol";
      eta = "Review in 48h";
    } else if (status === "Warning") {
      action = "Increase staffing by 1 tier";
      eta = "Review in 24h";
    } else if (status === "Action") {
      action = "Trigger protocol B + leadership notify";
      eta = "Act now";
    }
    els.kpiAction.textContent = action;
    els.kpiActionEta.textContent = eta;

    const shiftPct = ((average(recent, (d) => d.observed) / Math.max(1, average(records.slice(Math.max(0, n - 28), Math.max(0, n - 7)), (d) => d.observed))) - 1) * 100;
    els.mTrend.textContent = `${shiftPct >= 0 ? "+" : ""}${shiftPct.toFixed(1)}%`;

    const resid = average(recent, (d) => Math.abs(d.observed - d.latent));
    els.mDisp.textContent = `${resid.toFixed(1)} avg residual`;

    els.mConf.textContent = anom > 0.86 ? "High" : (anom > 0.7 ? "Moderate" : "Low");

    els.runbook.innerHTML = status === "Action"
      ? "Two consecutive Action days: activate surge staffing, notify on-call director, and lock threshold changes for 24h."
      : status === "Warning"
      ? "Warning state: increase staffing one level, monitor subgroup gap daily, and run threshold sensitivity check."
      : status === "Watch"
      ? "Watch state: prepare surge roster, validate data delays, and review model fit tomorrow."
      : "Normal state: maintain baseline operations and weekly threshold review.";

    drawTrend(records, score, status);
    drawGap(records, th.gap);
  }

  function render() {
    const records = subset();
    const th = thresholds(els.sensitivity.value);
    const focus = els.subgroup.value;
    renderKpis(records, th, focus);
    renderAlerts(records, th, focus);
    renderSubgroup(records, th.gap, focus);
  }

  ["change", "input"].forEach((ev) => {
    els.dateStart.addEventListener(ev, render);
    els.dateEnd.addEventListener(ev, render);
    els.sensitivity.addEventListener(ev, render);
    els.subgroup.addEventListener(ev, render);
  });

  render();
</script>
</div>


<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
  tabsets.forEach(function(tabset) {
    const tabby = new Tabby('#' + tabset.id);
  });
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'light-border',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>




</body></html>